.model      tiny            ; модель памяти, используемая для COM

.data 
siz dw 5
A dw 2, 4 ,5 ,7 ,1
B dw 2, 8 ,6 ,4 ,5
maxA dw ?
maxB dw ?


.code                       ; начало сегмента кода
            org     100h    ; начальное значение счетчика - 100h
getMax PROC 
pop dx
	pop si

	;Сделаем одну итерацию, чтобы самим инициализировать регистр с максимальным значением
	sub si, 2
	pop bx ;Пусть в bx хранится максимальное значение.
	cycleGetMax:
	sub si, 2
	pop ax
	cmp ax, bx
	
	jb more
	mov bx, ax
	more:
	
	cmp si, 0
	jne cycleGetMax
	;После цикла имеем в bx максимальное значение, закинем его в стек!!
push bx	
push dx
	RET                     
getMax ENDP 


funcY PROC 
pop bx
pop ax
cmp ax, 1 ;Сравниваю с единицей, Если ax меньше либо равно единицы, то скипаюсь.
jbe skip
cmp ax, 5 ;Сравниваю с пятёрой, если ax меньше либо равно пятёры, то иду в second
jbe second
;Иначе делаю вторую часть функции(надо добавить сравнение с десяткой)
cmp ax, 10 ;Ещё одна проверка на то, чтобы аргумент не выходил за границы.
ja skip ;Если ax больше 10, то скипаем

mul maxB
add ax, maxA
jmp skipPositiv
second:
mul maxA
add ax, maxB
jmp skipPositiv

;Позитивное окончание, переменная вошла в область определения
skipPositiv:
push ax
push bx
ret 
;Позитивное окончание, переменная вошла в область определения


;Окончание, соответствующее тому, что переменная не входит в область определения.    
skip:
mov ax, 0
push 0 
push bx
RET 
;Окончание, соответствующее тому, что переменная не входит в область определения.                 
funcY ENDP 




start:  

mov ax, @data
mov ds, ax
;1111111111 заполняем стек так,чтобы можно было вызвать функцию , сначала кладём элементы массива в любом порядке, далее размер массива*2
;Получим размер массива в байтах
mov cx, siz ;Подготавливаем счётчик si, по нему будем пробегать,чтобы получать элементы массива
mov ax, 2
mul cx
mov si, ax
;;;;Закинем в стек элементы
cycle1:
	sub si, 2
	mov ax, A[si]
	push A[si]
	
	cmp si, 0
	jne cycle1
;Закинем в стек ещё размер массива
mov cx, siz
mov ax, 2
mul cx
push ax
;1111111111	
;Зафиксируем первое максимальное значение
call getMax
pop maxA

;Получение второго максимального значения из второго массива
;222222222 заполняем стек так,чтобы можно было вызвать функцию , сначала кладём элементы массива в любом порядке, далее размер массива*2
;Получим размер массива в байтах
mov cx, siz ;Подготавливаем счётчик si, по нему будем пробегать,чтобы получать элементы массива
mov ax, 2
mul cx
mov si, ax
;;;;Закинем в стек элементы
cycle2:
	sub si, 2
	mov ax, B[si]
	push B[si]
	
	cmp si, 0
	jne cycle2
;Закинем в стек ещё размер массива
mov cx, siz
mov ax, 2
mul cx
push ax
;222222222	
;Зафиксируем второе максимальное значение
call getMax
pop maxB

;А теперь показательно закинем значения в ax и bx
mov ax, maxA
mov bx, maxB

;mov ah, 1h
;int 21h
;Будем вызывать значение через цикл.
mov cx, 10
cycle3:
	push cx
	call funcY
	pop ax
	loop cycle3


mov ax, 4c00h
int 21h






end start   ; конец программы