init_set_descriptor macro

set_descriptor proc near
; Создаёт дескриптор.
; DS:BX = дескриптор в GDT
; EAX = адрес сегмента
; EDX = предел сегмента
; CL = байт прав доступа (access_rights)
    push eax
    push ecx      ; Регистры EAX и ECX мы будем использовать.

    push cx       ; Временно сохраняем значение access_rights.

    mov cx, ax    ; Копируем младшую часть адреса в CX,
    shl ecx, 16   ; и сдвигаем её в старшую часть ECX.

    mov cx, dx      ; Копируем младшую часть предела в CX.
                    ; Теперь ECX содержит младшую часть
                    ; дескриптора (т.е. первые 4 байта -
                    ; см. рис. 4-1).
    mov [b ], ecx   ; Записываем младшую половину дескриптора в GDT.
    shr eax, 16     ; EAX хранит адрес сегмента, младшую часть
                    ; которого мы уже использовали, теперь будем
                    ; работать со старшей, для чего сдвигаем её в
                    ; младшую часть EAX, т.е. в AX.
    
    mov cl, ah  ; Биты адреса с 24 по 31
    shl ecx, 24 ; сдвигаем в старший байт ECX,
    mov cl, al  ; а биты адреса с 16 по 23 - в младший байт.

    pop ax      ; Возвращаем из стека в AX значение
                ; access_rights
    mov ch,al   ; и помещаем его во второй (из четырёх)
                ; байт ECX.
                ; Всё, дескриптор готов. Старшую часть
                ; предела и биты GDXU мы не устанавливаем и
                ; они будут иметь нулевые значения.
    
    mov [ bx + 4 ],ecx  ; Дописываем в GDT вторую половину
                        ; дескриптора.
    add bx,8    ; Переводим указатель в GDT на следующий
                ; дескриптор.
    pop ecx
    pop eax
    ret
endp

putzs proc near
; DS:BX = ZS ; ZS = Zero-String - строка, оканчивающаяся
             ; нулевым (00h) байтом.

; ES:DI = позиция вывода ; ES описывает сегмент видеопамяти,
                         ; DI - смещение в нём.
push ax
push bx
push es
push di
mov ah, 1bh     ; В AH будет атрибут вывода - светло-циановые
                ; символы на синем фоне.

putzs_1:
mov al, [bx]        ; Читаем байт из ZS-строки.
inc bx              ; Переводим указатель на следующий байт.
cmp al,0            ; Если байт равен 0,
je putzs_end        ; то переходим в конец процедуры.

mov es:[ di ],ax    ; Иначе - записываем символ вместе с
                    ; атрибутом в видеопамять по заданному
                    ; смещению - цветной символ появится на
                    ; экране.

add di,2    ; Переводим указатель в видеопамяти на
            ; позицию следующего символа. 
jmp putzs_1 ; Повторяем процедуру для следующего байта
            ; из ZS-строки.
putzs_end:
pop di
pop es
pop bx
pop ax
ret
endp

endm