model small ;модель памяти
.stack 256 ;размер стека
.data
	timeCx dw ? ;временная переменная
	A db 1,2,3,4,5,6,7,8,9,11 ;массив А
	B db 5,6,4,5,7,8,4,3,2,1  ;массив B
	C db 10 dup(0) ;результирующий массив
	len equ 10 ;длина массивов
.code
	start:
		push @data ;инициализируем ds физическим адресом данных
		pop ds  ;через стек
		mov cx,len ;ложим в сх длину
		xor si,si ;обнулили
		xor di,di ;обнулили
		xor ax,ax ;обнулили
	for1:
		push cx ;запомнили
		mov cx,len ;ложим длину
		xor di,di ;обнулили
	for2:
		mov bl,A[si] ;берем элемент первого массива
		cmp bl,B[di] ;смотри, есть ли во втором
		jne metka ;если нет, то метка
		push si ;если есть
		mov si,ax ;то ложим в результат
		mov C[si],bl ;через регистр
		inc ax ;переходим к следующему
		pop si ;вспомнили si из стека
	metka:
		inc di ;увеличили di
	loop for2 ;завершаем цикл
		pop cx ;вспомнилил сх
		inc si ;увеличили si
	loop for1 ;завершили цикл
		mov cx,len ;ложим в сх длину
		xor si,si ;обнуляем si
	lea bx,C
	call iskl ;вызываем процедуру
 	exit: ;выход
		mov ax,4c00h ;стандартный выход
		int 21h ;прерывание DOS
	iskl proc ;процедура для исключения одинаковых элементов
	cicl1: ;бежим по массиву
		push cx  ;запомнили
		mov timeCx,cx  ;положили во временную переменую
		mov cx,len ;установили на длину
		sub cx,si ;отняли то, что уже прошли
		mov di,si ;скопировали si в di
		push si ;запомнили в стек
	cicl2:  ;бежим по массиву и ищем одинаковые элементы
		inc di ;увеличили индекс
		mov al,[bx][si] ;положили в регистр текущий элемент массива
		push cx  ;запомнили сх
		mov cx,len ;положили в сх длину
		sub cx,di  ;отняли текущий индекс
		push si  ;запомнили si
		cmp al,[bx][di] ;скопировали в регистр
		push di ;запомнили di
		jne next ;если не равно то на next
		dec timeCx ;иначе уменьшили длину массива
	cicl3:  ;сдвигаем все элементы влево
		mov si,di ;ложим в si di
		inc di ;увеличиваем
		mov al,[bx][di]  ;ложим следующий в al
		mov [bx][si],al  ;ложим из al в текущий
		inc si ;переходим к следующему
	loop cicl3 ;конец цикла
	next:
		pop di ;вспомнили из стека
		pop si ;вспомнили из стека
		pop cx ;вспомнили из стека
	loop cicl2 ;конец цикла
		pop si ;вспомнили из стека
		pop cx ;вспомнили из стека
		mov cx,timeCx ;положили в сх текущую длину массива
		inc si ;увеличили
	loop cicl1  ;конец цикла
		xor si,si ;обнулили
		xor di,di ;обнулили
		mov cx,len ;положили длину
	cicl: ;если два одинаковых элемента рядом, проще учесть этот случай отдельно
		mov al,[bx][si] ;берем элемент
		cmp [bx][si+1],al ;сравниваем со следующим
		push cx ;запомнили сх
		jne n ;если не совпало, то на n
	incicl:  ;иначе
		mov di,si ;сдвигаем все, что справа
		inc di ;увеличили
		mov al,[bx][di] ;берем последующий
		mov [bx][si],al  ;заменяем им текущий
		inc si ;переходим к следующему
	loop incicl ;конец цикла
	n:
		pop cx ;вспомнили из стека
		inc si ;увеличили
	loop cicl ;конец цикла
		xor si,si ;обнулили
	ret ;возврат
	iskl endp ;конец процедуры
end start ;метка старт - вход в программу
